<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <link rel="stylesheet" href="jquery-ui.min.css" />
    <link rel="stylesheet" href="styles.css" />
    <script type="text/javascript" src="jquery-3.1.1.min.js"></script>
    <script type="text/javascript" src="jquery-ui.min.js"></script>
    <script type="text/javascript" src="summernote-lite.js"></script>
    <script type="text/javascript" src="app/cipherhandler.js"></script>
    <script type="text/javascript" src="app/cipherencoder.js"></script>
    <script type="text/javascript" src="app/cipheraffineencoder.js"></script>
    <script type="text/javascript" src="app/ciphervigenereencoder.js"></script>
    <script type="text/javascript" src="app/ciphersolver.js"></script>
    <script type="text/javascript" src="app/ciphercheckerboardsolver.js"></script>
    <script type="text/javascript" src="app/ciphergromarksolver.js"></script>
    <script type="text/javascript" src="app/ciphermorsesolver.js"></script>
    <script type="text/javascript" src="app/cipherfractionatedmorsesolver.js"></script>
    <script type="text/javascript" src="app/ciphermorbitsolver.js"></script>
    <script type="text/javascript" src="app/cipherxenocryptsolver.js"></script>
    <script type="text/javascript" src="app/ciphers.js"></script>
    <link rel="stylesheet" href="summernote-lite.css">
    <script src="math.min.js" type="text/javascript"></script>
    <script type="text/javascript" async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>
    <title>Hill Encrypt (2x2 and 3x3)</title>
</head>
<body>
    <h1>
        Hill Encrypt (2x2 and 3x3)</h1>
    <a href="index.html">Back to Cipher Tools</a>
    <hr />
    <label for="toencode">
        Text to encode</label>
    <input id="toencode" class="inp" title="Text to encode" type="text" />
    <div>
        <label for="key">
            key</label>
        <input id="key" class="inp" title="key" type="text" value="ABCD" /> <a href="HillKeys.html" target="new">Known Valid Keys</a>
    </div>
    <div class="err" id="err">
    </div>
    <input id="encrypt" type="button" value="encrypt" />
    <hr />
    <div class="ans" id="answer">
    </div>
    <p class="equations" id="equations">
    </p>
    <script type="text/javascript">
        var charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        var padval = "ZZZZZZZ";

        function gcd(a, b) {
            if (isNaN(a)) { return a; }
            if (isNaN(b)) { return b; }
            if (a < 0) { a = -a; }
            if (b < 0) { b = -b; }

            if (b > a) { var temp = a; a = b; b = temp; }
            while (true) {
              //  console.log('gcd a=' + a + ' b=' + b);
                if (b == 0) return a;
                a %= b;
                if (a == 0) return b;
                b %= a;
            }
        }
        function iscoprime(a) {
          //  console.log('iscoprime a=' + a + ' len=' + charset.length);
            var gcdval = gcd(a, charset.length);
          //  console.log('gcd(' + a + ',' + charset.length + ')=' + gcdval);
            if (gcdval != 1) {
                return false;
            }
            return true;
        }
        /**
        * Helper function to output a value in the console. Value will be formatted.
        * @param {*} value
        */
        function mprint(note, value) {
            var precision = 14;
            console.log(note + math.format(value, precision));
        }

        // Pad a string with the padding character based on the grouping size
        function padstr(str, groupsize) {
            var res = "";
            var i, len;
            console.log('padstr(' + str + ',' + groupsize + ')');
            str = str.toUpperCase();
            for (i = 0, len = str.length; i < len; i++) {
                var t = str.substr(i, 1);
                var x = charset.indexOf(t);
                if (x >= 0) {
                    res += t;
                }
            }
            console.log(res);
            var topad = (groupsize - (res.length % groupsize)) % groupsize;
            res += padval.substr(0, topad);
            return res;
        }

        function isvalidkey(key) {
            var vals = [];
            var groupsize;
            if (key.length != 4 && key.length != 9) {
                $('#err').text('Invalid key.  It must be either 4 or 9 characters long');
                return null;
            }
            // Figure out how big our array for encoding is
            groupsize = math.sqrt(key.length);

            // Parse out the key and create the matrix to multiply by
            for (i = 0, len = key.length; i < len; i++) {
                var row;
                t = key.substr(i, 1).toUpperCase();
                x = charset.indexOf(t);
                if (x < 0) {
                    console.log('Invalid character:' + t);
                    $('#err').text('Invalid key character:' + t);
                    return null;
                }
                row = Math.floor(i / groupsize);
                if (typeof vals[row] === 'undefined') {
                    vals[row] = [];
                }
                vals[row][i % groupsize] = x;
            }

            var determinant = math.det(vals);
            if (determinant == 0) {
                $('#err').text('Matrix is not invertable');
                return null;
            }
            if (!iscoprime(determinant, charset.length)) {
                $('#err').text('Matrix is not invertable.  Determinant ' + determinant + ' is not coprime with ' + charset.length);
                return null;
            }
            return vals;
        }
        
        function hill(key, str) {
            var res = "";
            var vals = [];
            var i, len, t, groupsize, x;
            vals = isvalidkey(key);

            if (vals === null) {
                console.log('****RETURNING****');
                return '';
            }
            // Figure out how big our array for encoding is
            groupsize = math.sqrt(key.length);

            // pad out the string to contain full groups of the group size
            str = padstr(str, groupsize);
           
            //console.log('Determinant =' + math.det(vals));
            // console.log('Inverse =' + math.inv(vals));

            mprint('Encoding Array:',vals);
            var equation = '';
            // Go through the string in the group size and perform the math on it
            for (i = 0, len = str.length; i < len; i += groupsize) {
                var cluster = [];
                for (j = i; j < i + groupsize; j++) {
                    t = str.substr(j, 1);
                    x = charset.indexOf(t);
                    if (x < 0) {
                        $('#err').text('Internal error:' + t + ' invalid character');
                        return '';
                    }
                    cluster.push(x);    // cluster.push([x]);
                }
                var clustervals = math.multiply(vals, cluster);
                mprint('Cluster:',cluster);
                mprint('Result', clustervals);
                for (j = 0; j < groupsize; j++) {
                    res += charset.substr(clustervals[j] % charset.length, 1);
                }
                // Build a big long string from each encoding that represents 
                // the equations using MathJax.
                equation += buildEquation(groupsize, vals, cluster, clustervals);
            }
            $('#err').text('');
            //            for (i = 0, len = str.length; i < len; i++) {
            //                t = affinechar(a, b, str.substr(i, 1));
            //                res += t;
            //            }
            $('#equations').text(equation);
            // Dont show matrix math equations yet, htey need to be typeset
            // which is done on button click.
            $('#equations').hide();
            return res;
        }
        function calc() {
            var key = $('#key').val();
            var toencode = $('#toencode').val();
            console.log('key=' + key + ' encode=' + toencode);

/* This set of words allows quick testing to find the known keys */
var words=[
];

for (var i = 0; i < words.length; i++) {
    if (isvalidkey(words[i]) != null) {
        console.log("Valid key:"+words[i]);
    }
}
            var res = hill(key, toencode);
            $("#answer").text(res);
        }

        /**
         * This function builds an equation for a single 'row'
         * 
         * @param {integer} size of the key matrix dimensions (sq. root of key lenght)
         * @param {array} array of key letter values (i.e. size x size)
         * @param {array} array of message letter values (i.e. size x 1)
         * @param {array} array of encoded letter values (i.e. size x1)
         * @returns {string} MathJax string of entire matrix math equation
         */
        function buildEquation(size, keyArray, msgArray, resultArray) {

            var equation = ''
            var row, col;

            // Set up MathJax for each matrix (we are using {array} because
            // elements can be centered.  We put verical bars around it to
            // make it look like a matrix.)
            var keyLetters = '$$\\left|\\begin{array}{cc}';
            var msgLetters = '\\left|\\begin{array}{c}';
            var keyValues = '\\left|\\begin{array}{cc}';
            var msgValues = '\\left|\\begin{array}{c}';
            var multiplying = '\\left|\\begin{array}{c}';
            var resultValues = '\\left|\\begin{array}{c}';
            var resultMod26 = '\\left|\\begin{array}{c}';
            var resultLetters = '\\left|\\begin{array}{c}';

            // This will hold the calculated value of the matrix element
            // multiplication.
            var x;
            // Loop through the rows and colums and build the equations string.
            for (row = 0; row < size; row++) {
                x = 0;
                for (col = 0; col < size; col++) {
                    // Append element delimiter after first element.
                    if (col > 0) {
                        // elements in matrices with more than one column are 
                        // delimited with '&'.  The '+' is for the element
                        // multiply equation.
                        keyLetters += ' & ';
                        keyValues += ' & ';
                        multiplying += ' + ';                        
                    }
                    // Use typewriter font throughout...
                    // Fill in the elements for all the multi-column matricies
                    keyLetters += ('\\mathtt{'+charset.substr(keyArray[row][col], 1)+'}');
                    keyValues += ('\\mathtt{'+keyArray[row][col]+'}');
                    multiplying += (('\\mathtt{'+keyArray[row][col] + ' \\cdot ' + msgArray[col]+'}'));
                    x += keyArray[row][col] * msgArray[col];
                }                
                // Fill in the elements for all the single column matricies
                msgLetters += ('\\mathtt{'+charset.substr(msgArray[row], 1)+'}');
                msgValues += ('\\mathtt{'+msgArray[row]+'}');
                resultValues += ('\\mathtt{'+x+'}');
                resultMod26 += ('\\mathtt{'+(x % charset.length)+'}');
                resultLetters += ('\\mathtt{'+charset.substr(x % charset.length, 1)+'}');
                // Add a row separator except after the last row.
                if (row !== size-1) {
                    keyLetters += '\\\\';
                    msgLetters += '\\\\';
                    keyValues += '\\\\';
                    msgValues += '\\\\';
                    multiplying += '\\\\';
                    resultValues += '\\\\';
                    resultMod26 += '\\\\';
                    resultLetters += '\\\\';
                }
            }
            // Close off each matrix (array)
            keyLetters += '\\end{array}\\right|';
            msgLetters += '\\end{array}\\right|';
            keyValues += '\\end{array}\\right|';
            msgValues += '\\end{array}\\right|';
            multiplying += '\\end{array}\\right|';
            resultValues += '\\end{array}\\right|';
            resultMod26 += '\\end{array}\\right|';
            // The extra four $'s create some space between equations
            resultLetters +='\\end{array}\\right|$$$$$$';

            // Build the complete equation string using operators and
            // whatnot between each matrix.
            equation += keyLetters;
            equation += ' \\cdot ';
            equation += msgLetters;
            equation += '\\equiv';
            equation += keyValues;
            equation += ' \\cdot ';
            equation += msgValues;
            equation += '\\equiv';
            equation += multiplying;
            equation += '\\equiv';
            equation += resultValues;
            equation += '\\equiv';
            equation += resultMod26;
            equation += '\\text{(mod 26)}\\equiv';
            equation += resultLetters;

            // Done!
            return equation;
        }

        $(".inp").change(function () {
            calc();
        });
        $(".inp").blur(function () {
            calc();
        });
        $('#encrypt').button().click(function () {
            // Only do the hardcore stuff when the button is clicked.
            // Set it to 'zoom' the equation on hover.
            MathJax.Hub.Config({
                menuSettings: {
                    zoom: "Hover"
                }
            });
            calc();
            // Now that the calculations have been done, 
            // asynchronously typeset them.
            MathJax.Hub.Queue(['Typeset',MathJax.Hub,'equations']);
            // Show equations
            $('#equations').show();
        })
    </script>
</body>
</html>
